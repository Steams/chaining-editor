* TODO REMEBER TO ADD COPY SCRIPT IN 
* Scrits for coopy
before elm script :
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>

after elm script :
<script>
 new ClipboardJS('.copy');
</script>

# * <script> var clipboard = new Clipboard('copy-button')</script>

input id="foo" value="https://github.com/zenorocha/clipboard.js.git">

<!-- Trigger -->
<button class="btn" data-clipboard-target="#foo">
    <img src="assets/clippy.svg" alt="Copy to clipboard">
</button>
* MSG to client
** having the input separate didnt make sense when you switch chains it would have to change what ur input was restricted to
** can have input separate if you still want
** remember that if u dont press space before moving to a new chain it wont show. But its still there if you go bacl tp the chain
** If you encounter a series of input where line break doesnt work properly, send screenshot
*** Still working on newline logic
** The text you are current typing doesnt count as in the document until you hit space or enter

* Interface Upgrades
** Copy should include \n
** TODO Fix newline
*** Fix newline logic (looks like the spacing uses the current length for the hidden current word, just add the space of the hidden entry point instead)
** font measuring for nicer than monospace font

** Copy Button
*** DONE Copy Button
*** DONE Test copy

** TODO UI
*** DONE Text spacing, line height, font size
*** DONE Nicer text for status bar
*** DONE Different color for text being input
*** DONE Subtle Background color for input slot?
*** DONE Pick nicer colors for pointer
*** layout
**** TODO Fixed header position
*** Buttons
**** DONE Copy
**** DONE New chain
**** DONE finsh button styles (rounded ?)
**** TODO button that starts new paragraph and a new chain
*** Status displa
**** DONE char count
**** DONE chain count
**** Longest chain
*** TODO ensure widths relative
*** DONE dont render "none" for empty chain, render small input with red orb
*** DONE denote input field
*** DONE denote End of a chain
*** DONE grey out prefix list

** DONE make entry point of empty chain visible so u can click back to it
** DONE add delete chain icon
** Ctrn + n = new chain
** Ctrn + p = new paragraph + new chain
** TODO Disable debug mode
** display list of chains and a way to switch to them in corner (Nah)


* BUGS
*** DONE if u type the same letter twice u cant backspace the duplicate
*** DONE THe js generated by elm, after re rendering input, selects my input by its position in dom list, which has now changed.
**** You may fix this by storing prev as a single element when not editing it, and on click change it to list of input
**** Might can fix with Html.Keyed and assigned a key to each el and lazy for non changed divs
**** DONE Fixed with manual call to focus through Task


*** DONE Cant edit previous words
*** DONE allow backspace of first char if its the first word (covered by delete chain)

* Idea
** DONE Try setting input width to (shirnk |> Element.maximum ...)
** DONE calculate width to make \n element by counting chars words before, convert to px by times 20, subtract from box length
*** DONE *THIS ACTUALLy needs to be length of chars since the last \n*

** You dont need to implement backsace between words because u ant allowed to do that anyways
** button that inserts a chain with just \n
** DONE Ensure \n on enter words with multiple chains
** DONE Measure previous char length over the whole line (multiple chains) now just the current chain.


* TODO
** DONE Backspacing the previous word entry
** DONE Manual place cursor
*** Text area containing spans of each char and input for current
*** DONE Text area, followed by input, followed by text div
**** type in input, on space add text to textbox on left and add unremovable letter then fresh input after,
**** on change, render out representation of new list, ziplist with old list, if they match keep, if not put old list starter in that pos
**** position at first vacant slot
**** Limitation : cant make starting letters in previous words non editable, would have to do individual inputs for that
*** List of inputs

** DONE Periods don’t need to be part of the chain, so no repeating punctuation (all punctuation)
*** write tests for punctuations

** DONE Double letter error (I’m able to totally delete the two letters but that would break the chain)
** DONE handle mouse select and delete multiple aswell. (dont just heck if new string = old string - head, check if newstring = oldstring - (old length - newlength)

** New text needs to populate somewhere else. It’s going ‘behind’ the entry lines and I can’t read it. New text on top, and entry point at bottom?
*** DONE Having the entry point shift over as the paragraph progresses, much like the cursor normally would in a regular text editor
*** Having the entry point not exist inside the paragraph itself, but below the text area
*** button to switch between these modes

** Button to start new chain and end previous
*** DONE Button to start new chain
*** DONE where to store newline delimiters ?

** DONE A new line or paragraph should continue the the existing chain
*** DONE Support \n multiplline : on enter, append \n to end of current string. Ask how he wants enter to be handled

** DONE Text entry field needs to expand for long new text so it doesnt go under the prefix list



** DONE Cannot backspace first letter of generated word
** DONE Edit previous word and regenerate
** DONE Stop backspace of first newchar, same logic as on renrender

* On rerender
** DONE Stop first letter deletion
*** when change, check which word in current str is different from old
*** if its first character that changed, dont allow
*** if its a different char that changed, then proceed to regenerate
*** generate layout structure (all the letters in order) from new sentence, then check if each word first char matches the char at its positioin in list,
*** stop at the first word that doesnt match, and start input from there
** DONE regenerate new prefix list and check each word againsts its prefix
*** DONE stop on the first fail
*** DONE use the rest of the prefix list as the words themself for the rest of the model
* pass inputprevious a list of all strings and list of the number of strings in each chain
* get its current chain (chain_id) and its position in the chain (indexMapped)
* take all words up to chain_id by finding the chain_idTH member of the length list and taking from the whole list up to before it
* add to that. take up to its position in the chain
* flatten that to string and reverse that and search for position of \n 
* *THIS NEEDS TO IGNORE PREFIXES*

"}The hen. }Entry now.\n"
(Thehen.,7),(Entrynow.\n,9)
(The hen.

[7,9]

[[7,9],10]
